# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48323621/)
```
#:48323621
题目:P1050
提交人:2400090404_李实
内存:3712kB
时间:28ms
语言:Python3
提交时间:2025-02-21 19:59:29
```
### 走迷宫之一
最基础的走迷宫问题，主要靠维护单调栈实现
题目在条件上已经有简化，给定了起点和终点，我们只需要判断是否存在一条可以抵达终点的路径即可
### 思路
我们模拟正常人走迷宫时的思路，先挑选一条路线，一条路走到黑，如果碰壁是死路，那就退回到上一个岔路口，再走另一条。重复此过程直到抵达终点，或者穷尽所有的路线仍然无法战胜。同时我们需要标记所有走过的路线，以防我们重蹈覆辙，走之前的死路。\
我们创建一个栈（stack）来储存走过的路线，每走到一格就把它存到栈里，如果遇到死路要开始后退，那我们就开始弹栈，直到有当前位置岔路口可以重新选择路径。\
每走到一格，我们把当前位置记作now，先判断now是否是终点，如果是则输出‘1’，如果不是，那么我们开始遍历now的上下左右四格，选择这四格里面不超过地图边界且不是墙壁的坐标，作为我们下一步的位置，并把它存到栈里，同时把这个点换成墙壁（以防以后再走一遍）。如果不存在可以走的路线，那么我们可以定义一个back旗帜，如果back==True，那么我们就开始弹栈。由于先前已经把走过的路线变成了墙壁，因此到岔路口走的一定是新的路线。\
于是，我们就可以通过这种方式，遍历每一条可能路径。
### 代码实现：
```python
def Maze(M,start):
    stack = [start]#利用栈来存储走过的路线
    m = len(M)
    n = len(M[0])
    while stack:
        now = stack[-1]
        i,j = now
        if i==m-1 and j==n-1:
            return'1'

        M[i][j] = "#"#标记走过了!!!不走回头路
        back = True
        for x,y in (i-1,j),(i+1,j),(i,j+1),(i,j-1):
            if 0 <= x <= m-1 and 0 <= y <= n-1:
                if M[x][y] != '#':
                    stack.append((x,y))
                    back = False
                    break
        if back:
            stack.pop()#一直回到上一个可选节点
            continue
    else:
        return '0'
m,n = tuple(map(int,input().split()))
M = [list(input()) for i in range(m)]
print(Maze(M,(0,0)))
```

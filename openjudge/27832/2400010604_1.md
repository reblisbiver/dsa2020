# 状态: [Accepted](http://xzmdsa.openjudge.cn/hwreview2025/solution/49330254/)

```
基本信息
#:
49330254
题目:
250208
提交人:
2400010604李凯瑞
内存:
7104kB
时间:
246ms
语言:
Python3
提交时间:
2025-06-02 21:26:32
```

## 说明
我们需要高效地处理查询操作。找到一种方法，使得查询操作的时间复杂度降低到O(1)或接近O(1)。

### 方法思路
1. **预处理位信息**：对于每个数的每一位（0到15），我们预先统计初始时每一位上有多少数是1。这样可以用一个二维数组`bit_counts`来记录，其中`bit_counts[i][j]`表示在第`i`位上有多少数的二进制表示中该位是1。

2. **处理修改操作**：每次修改操作（即所有数增加`d`）可以视为一个全局的累加。我们维护一个全局的累加值`total_add`，表示所有数实际需要增加的总值。由于每次增加后需要对65536取模，`total_add`的范围也应在0到65535之间。这样，实际每个数的值为`(original_value + total_add) % 65536`。

3. **查询位信息**：查询第`i`位为1的数的个数时，可以利用预处理的信息和当前的`total_add`来快速计算。具体来说，对于第`i`位，一个数`x`在加上`total_add`后的第`i`位是否为1，取决于`(x + total_add) >> i & 1`是否为1。由于`x`的范围是0到65535，我们可以预处理一个数组`mask`，其中`mask[i][j]`表示初始值为`j`的数在全局累加`total_add`后第`i`位是否为1。但这样预处理的空间复杂度可能较高。相反，我们可以利用数学方法：对于第`i`位，`(x + total_add) % 65536`的第`i`位是否为1，取决于`(x + total_add) & (1 << i)`是否不为零。这等价于`(x + total_add) mod 65536`在某个区间内。具体来说，第`i`位为1的充要条件是`(x + total_add) mod 65536`在区间`[k*2^(i+1) + 2^i, (k+1)*2^(i+1) - 1]`对于某些`k`。因此，我们可以将问题转化为统计原始数`x`满足`x mod 2^(i+1)`在某个区间内的个数。

4. **高效统计**：对于每个查询操作的第`i`位，我们需要统计满足`(x + total_add) mod 65536`的第`i`位为1的`x`的个数。可以将问题拆解为统计满足`(x mod 2^(i+1)) + (total_add mod 2^(i+1))`的结果在`[2^i, 2^(i+1) - 1]`模`2^(i+1)`的`x`的个数。因此，可以预处理每个数`x`的`x mod 2^(i+1)`的值，并对每个可能的余数`r`（0到`2^(i+1)-1`）统计出现次数。这样，查询时只需计算`(r + total_add_mod) mod 2^(i+1)`是否在目标区间即可。


### 代码解释
1. **输入处理**：使用快速读取方法读取输入数据，包括整数个数`N`、操作数`M`，以及初始的整数数组。
2. **预处理位信息**：对于每个可能的位（0到15），预处理每个数对该位模`2^(i+1)`的余数，并统计每个余数的出现次数。这样可以在查询时快速计算满足条件的数的个数。
3. **处理操作**：
   - **修改操作（C d）**：维护一个全局累加值`total_add`，每次增加`d`后取模65536。
   - **查询操作（Q i）**：利用预处理的信息，计算当前全局累加值下，满足第`i`位为1的数的个数。具体做法是检查每个余数`r`加上`total_add`的对应位是否在目标区间内，并累加对应的出现次数。
4. **输出结果**：将所有查询操作的结果收集后统一输出，以提高效率。

这种方法通过预处理和数学技巧将查询操作的时间复杂度优化至O(1) per bit per query，从而高效处理大规模数据。
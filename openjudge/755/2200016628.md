### 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/49292646)
```
#:49292646
题目:P1180
提交人:B-2200016628-谢艺
内存:3980kB
时间:32ms
语言:Python3
提交时间:2025-05-29 13:23:24
```

## 解题：
BFS 适合求解最短路径问题，这里每个棋盘状态是一个节点，每次操作（翻转某个格子）是边，我们需要从初始状态出发，找到到达全白或全黑状态的最短路径。

1. `board_to_int(board)`: 将棋盘转为整数
	将 4x4 的棋盘压缩成一个 16 位整数。每一个格子用一位（bit）表示：黑（`b`）为 `1`，白（`w`）为 `0`。
		例如，棋盘左上角格子对应第 0 位，右下角对应第 15 位。  
		**优势**：用整数表示状态，便于快速存储和比较，且可利用位运算高效操作。

2. `generate_flip_masks()` 函数会为每个格子生成一个 **翻转掩码**（`mask`）
    掩码中为 `1` 的位，表示需要翻转的棋子。
3. **BFS 遍历状态空间**
		每次从队列中取出当前状态，尝试所有 16 种翻转操作（遍历所有掩码），通过异或运算（`^`）生成新状态：
		- **剪枝优化**：用集合`visited`记录已访问的状态，避免重复处理，减少计算量。